| Namn och förklaring | Reflektion och regler från Clean Code |
|---------------------|---------------------------------------|
| **PasswordValidator** <br> Klassnamn på en av huvudklasserna i modulen  | **Class Names** <br> Klasser och objekt skall innehålla substantiv. Ett klassnamn skall inte innehålla verb. Både “password” och “validator” är därför passande i detta fall. <br> **Use Solution Domain Names** <br> Min kod är främst till för andra utvecklare. De flesta utvecklare förstår innebörden med “validator” och därför är denna tekniska term passande och hintar till att något skall valideras.|
| boolean <br> **hasDangerousChars()** <br> Metodnamn på metod som avgör om ett lösenord innehåller “farliga” symboler.  | **Use Intention-Revealing Names** <br> Namnet avslöjar metodens avsikt. Man förstår varför den existerar, vad den gör och att den returnerar ett boolsk värde. <br> **Avoid Disinformation** <br> Det kanske hade blivit tydligare om jag hade döpt metoden till containsPotentiallyHarmfulHTMLSymbols(), då “Dangerous” kan låta lite diffust. Men jag väljer att behålla mitt metodnamn då det inom kontexten av klassen “PasswordValidator” borde vara uppenbart för en utvecklare vad definitionen “Dangerous” syftar till.| 
| boolean <br> **ageLength()** <br> Metodnamn på metod som avgör om en ålder innehåller fler än tre siffror  | **Method Names** <br> Metodnamn bör innehålla verb. Mitt metodnamn är tvetydigt och diffust då avsikten för metoden kan feltolkas/misstolkas. Jag borde hellre ha döpt den till isAgeLengthAboveThree() eller isAgeLengthValid() då det tydligare definerar metodens avsikt. Jag väljer att döpa om metodnamnet i detta fall, till isAgeLengthValid(). <br> **Add Meaningful Context** <br> Metodnamnet ger ingen direkt kontext eller bättre förståelse för avsikten för metoden. Man skulle kunna misstolka att metodens avsikt är att avgöra hur långt en “ålder” är (hur många tecken). Eftersom det även skall returnera ett boolsk värde borde metodnamnet bestå av ett verk och jag bör lägga till antingen “is” eller “has” som prefix.
boolean <br> **hasUpperCase()** <br> Metodnamn på metod som avgör om ett lösenord innehåller stor bokstav.  | **Use Searchable Names** <br> Man skall försöka undvika klassnamn/metodnamn som enbart består av en enda bokstav eller som innehåller siffror. Dessa kan vara svåra att lokalisera i koden, samt att siffror kan förekomma inuti andra funktioner eller vara delar av filnamn. “hasUpperCase()” är både lätt sökbart och kommunicerar metodens avsikt bra. <br> **Avoid Mental Mapping** <br> Andra utvecklare skall inte behöva översätta dina klassnamn/metodnamn/variables mentalt. Namn som består av en bokstav är ofta variabler som innehåller ytterliggare information. Det förekommer ofta inom loopar etc. Jag skulle kunna ha döpt min metod till, till exempel “A” eller “ABC”, vilket jag själv hade förstått men alla utomstående utvecklare hade behövt klura ut metodens avsikt. 
boolean <br> **Validate()** <br> Metodnamn på metod som validerar input baserat på vilka “regler” som utvecklaren valt att implementera.  | **Don’t Add Gratuitous Context** <br> Metodnamnet är kort och tydligt och förmedlar metodens avsikt, nämligen att validera input. Jag skullekunna  ha döpt om metoden inom varje klass till “EmailValidate()” eller “AgeValidate” men detta skulle göra metodnamnet längre utan att tillsätta något egentligt värde.  <br> **Pick One Word per Concept** <br> Metodnamnet följer regeln då det konsekvent och tydligt använder ett välkänt ord för att beskriva valideringsprocessen inom de olika klasserna. Genom att hålla mig till “validate” och inte införa synonymer som till exempel “check”, “verify” eller “control” försäkrar jag mig om att undvika förvirring hos andra utvecklare.

## Reflektion kapitel 2
#### Man inser hur viktigt det är med själva namngivningen av sina klasses/metoder/variables ju längre in man kommer i ett projekt. När applikation har vuxit och innehåller flera tusen rader kod, är det oerhört viktigt att kunna utläsa och hitta sin specifika metod eller klass. Dels för buggfixning men också för tydlighetens skull. Därför är det viktigt att från första början skapa bra och tydliga namn så att man i ett senare skede slipper slösa onödig energi. Detta gäller för en själv såväl som för andra utvecklare som vidareutvecklar med hjälp av din kod. I många fall kommer man undan med namn (som kunde ha varit tydligare) som andra utvecklare eller personer inom branschen ofta förstår och enhälligt tolkar på samma sätt. Men i de flesta fall är det säkrare att använda så deskreptiva och tydliga namn som möjligt, utan att ta med överflödig information och utan att hinta till annan mental mapping. Tex i mitt fall då jag använde “ageLength()” innan jag döpte om namnet till “isAgeLengthValid”.  En utvecklare som tittar på metodnamnet “ageLength()” inom kontexten för klassen “AgeValidator” hade säkerligen kunnat dra slutsatsen att metoden på något sätt validerar längden (antalet siffror) på användarens “age” input. Jag valde trots detta att förtydliga mitt metodnamn is “isAgeLengthValid()”, dels för att metoden returnerar ett boolsk värde, dels för att metodnamnet bör innehålla ett verb och sist men inte minst för att ännu mer tydliggöra metodens avsikt. <br><br><br><br><br><br><br>

| Metodnamn och länk eller kod | antal rader | Reflektion och regler från Clean Code |
|------------------------------|-------------|---------------------------------------|
| boolean <br> **isLongEnough(password)** <br> Klassnamn på en av huvudklasserna i modulen  | 11 | **Verbs and Keywords** <br> Metodnamnet använder ett verb(is) kombinerat med ett beskrivande substantiv (LongEnough), vilket tydliggör metodens avsikt. Genom att använda verbet “is” tydliggör man att metoden handlar om att kontrollera något och returnera ett boolskt värde och argumentet “password” tydliggör vad som kontrolleras. Jag väljer dock att ändra mitt metodnamn till “isPasswordLongEnough” för att ytterliggare tydliggöra the “keyword” som skall kontrolleras. <br> **Prefer Exceptions to Returning Error Codes** <br> Min metod returnerar ett objekt som innehåller både en boolean (isValid) och ett felmeddelande (message) vid ogiltigt lösenord. Istället för att använda denna metoden och signalera ett fel (error code) borde jag istället kasta ett undandag (exception) för att separera den vanliga logiken (happy path) och felhanteringen. Jag väljer dock att ha kvar min kod för tillfället då jag har implementerat detta tillvägagångasätt i alla mina klasser.|
| boolean <br> **hasSpecialChar()** <br> Metodnamn på metod som avgör om ett lösenord innehåller “speciella” symboler.  | 12 | **Small** <br> Metoden är under 20 rader lång, kompakt och överskådlig. Den är tydlig, fokuserar enbart på en sak och är lätt att läsa. <br> **One Level of Abstraction per Function** <br> Metoden följer regeln eftersom den håller sig till en och samma abstraktionsnivå. Den validerar lösenordet mot ett reguljärt uttryck. Både definieringen av regex-mönstret samt returneringen av valideringsresultatet befinner sig på samma abstraktionsnivå. Den manipulerar ej systemvariabler eller renderar någon data, vilket skulle kräva flera nivåer av abstraktion.  | 
| boolean <br> **hasDangerousChars()** <br> Metodnamn på metod som avgör om ett lösenord innehåller “farliga” symboler.  | 16 | **Use Descriptive Names** <br> Metodnamnet innehåller verbet “has” och substantivet “DangerousChars” vilket tydligt beskriver att metoden kontrollerar och returnerar ett boolsk värde baserat på om den hittar farliga tecken. Jag väljer dock att ändra namnet till det längre men ännu mer tydliga namnet “containsDangerousCharactersInPassword” <br> **Blocks and Indenting** <br> Metoden innehåller visserligen två nivåer av identering (en för for-loopen och en för if-satsen) men jag väljer ändå att behålla metoden som den är eftersom den ligger inom den rekommenderade gränsen (1-2 nivåer). Vidare är blocken korta, metoden är relativt liten och fokuserar på en specifik uppgift.|
| boolean <br> **hasAtSymbol()** <br> Metodnamn på metod som avgör om en email innehåller “@” symbolen.  | 10 | **Do One Thing** <br> Metoden följer regeln på ett bra sätt eftersom den bara gör en sak. Dess enda funktion är att kontrollera om en e-postadress innehåller tecknet “@” och utför inget annat överflödigt arbete.  <br> **Function Argument** <br> Metoden har bara ett argument (email) och följer således formen för en monadisk funktion. Regeln beskriver två vanliga former för en monadisk funktion, en där man ställer en fråga om argumentet och en där man transformerar det. Namnet på metoden tydliggör att en fråga ställs, om email-strängen innehåller symbolen “@”.|
| boolean <br> **hasDotSymbol()** <br> Metodnamn på metod som avgör om en email innehåller “.” symbolen.  | 11 | **Command Query Seperation** <br> Metoden följer principen om att en funktion antingen skall göra något (ett kommando) eller besvara något (en fråga). I mitt fall besvarar den frågan om email-strängen innehåller en punkt och ändrar inte något tillstånd på argumentet/objektet. <br> **Have No Side Effects** <br> Metoden följer regeln bra eftersom den gör exakt vad den lovar. Den kontrollerar om en email-sträng innehåller en punkt. Vidare undviks “temporal coupling” eftersom metoden ej utför någon annan operation än just att kontrollera om strängen innehåller en punkt. Inga dolda eller andra systemresurser anropas vilket gör att metoden kan anropas när som helst, utan att bero på någon specific ordning eller vara beroende av ett visst tillstång. |


## Reflektion kapitel 3
#### Efter att ha läst kapitel 3 så inser jag att det finns många bra regler som man borde förhålla sig till. Dem existerar för att tydliggöra och förenkla läsbarheten av funktioner. I mitt fall så bryter jag mot regeln: **Prefer Exceptions to Returning Error Codes**, men valde ändå att behålla min kod den här gången. Inför nästa uppgift kanske jag skapar try/catch block och implementerar denna regel. Jag förbättrade även namnet för min metod “hasDangerousChars” till “containsDangerousCharactersInPassword” för att följa regeln **Use Descriptive Names**.

#### Eftersom min modul är ganska liten och mina metoder relativt små och korta, har jag lyckats följa majoriteten av reglerna från kapitel 2 och 3. Jag har lärt mig betydelsen av att ge klasser/metoder tydliga och deskreptiva namn och att man inte skall vara rädd för långa namn. Man bör dock undvika namn som är överflödiga, ger disinformation eller som kräver mental mapping. Det som är uppenbart för mig kanske inte alltid är uppenbart för andra. Man skall även försöka vara konsekvent när man namnger sina metoder och inte använda synonymer på verb som utför samma operation. Mina metoder följer reglerna från kapitel 3 rätt bra då dem är simpla och korta i sin natur. De flesta gör enbart en sak och det är att validera en sträng och returnera ett boolsk värde. De utför alltså enbart en query och utför inte någon operation samtidigt eller förändrar att arguments/objekts tillstånd eller värde. De skapar inte några sidoeffekter som har oväntade konsekevensker utan håller sig till att utföra en sak. Vidare följer mina metoder även regeln **“Verbs and Keywords”** bra då de har “is, has, contains som prefix med efterföljande substantiv på vad som kontrolleras. Det jag skulle kunna jobba på mer och förbättre är enligt regeln **"Blocks and Indenting"**.  Denna regeln har jag inte aktivt tänkt på när jag kodar och den kräver även att jag på ett annat sätt tänker på hur jag strukturerar och bryter ut min kod. 











